From e1ad9b1074af8b23a60e04bcb7b647d2bcfa80f9 Mon Sep 17 00:00:00 2001
From: Jaedon Shin <jaedon.shin@gmail.com>
Date: Thu, 23 Aug 2018 11:57:27 +0900
Subject: [PATCH] qcacld-2.0: Make driver compatiable with mainline kernel

Signed-off-by: Jaedon Shin <jaedon.shin@gmail.com>
---
 CORE/CLD_TXRX/HTT/htt_rx.c                    |   6 +-
 CORE/CLD_TXRX/TXRX/ol_tx.c                    |  13 +-
 CORE/CLD_TXRX/TXRX/ol_tx.h                    |   6 +-
 CORE/CLD_TXRX/TXRX/ol_tx_queue.c              |  14 +-
 CORE/EPPING/src/epping_txrx.c                 |   6 +-
 CORE/HDD/inc/wlan_hdd_p2p.h                   |   8 +-
 CORE/HDD/src/wlan_hdd_assoc.c                 |   4 +
 CORE/HDD/src/wlan_hdd_cfg80211.c              | 153 +++++++++++-------
 CORE/HDD/src/wlan_hdd_early_suspend.c         |  10 +-
 CORE/HDD/src/wlan_hdd_hostapd.c               |   4 +
 CORE/HDD/src/wlan_hdd_main.c                  |  18 ++-
 CORE/HDD/src/wlan_hdd_nan_datapath.c          |   6 +-
 CORE/HDD/src/wlan_hdd_p2p.c                   |  29 +++-
 CORE/HDD/src/wlan_hdd_tx_rx.c                 |   2 +
 CORE/SERVICES/COMMON/adf/adf_os_types.h       |   8 +-
 .../COMMON/adf/linux/adf_os_dma_pvt.h         |   9 ++
 .../COMMON/adf/linux/adf_os_timer_pvt.h       |   7 +
 CORE/SERVICES/COMMON/osdep_adf.h              |  10 +-
 CORE/SERVICES/HIF/PCIe/copy_engine.c          |   6 +-
 CORE/SERVICES/HIF/PCIe/hif_pci.c              |   6 +-
 CORE/SERVICES/HTC/htc_internal.h              |   2 +-
 CORE/SERVICES/HTC/htc_send.c                  |   6 +-
 CORE/VOSS/src/vos_nvitem.c                    |   2 +
 CORE/VOSS/src/vos_timer.c                     |  13 +-
 Kbuild                                        |   3 +-
 Makefile                                      |   6 +
 26 files changed, 276 insertions(+), 81 deletions(-)

diff --git a/CORE/CLD_TXRX/HTT/htt_rx.c b/CORE/CLD_TXRX/HTT/htt_rx.c
index bf44d237592e..7dc3fcab3f8b 100644
--- a/CORE/CLD_TXRX/HTT/htt_rx.c
+++ b/CORE/CLD_TXRX/HTT/htt_rx.c
@@ -205,9 +205,13 @@ htt_rx_ring_fill_level(struct htt_pdev_t *pdev)
 }

 static void
-htt_rx_ring_refill_retry(void *arg)
+htt_rx_ring_refill_retry(compat_timer_arg_t arg)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    htt_pdev_handle pdev = from_timer(pdev, arg, rx_ring.refill_retry_timer);
+#else
     htt_pdev_handle pdev = (htt_pdev_handle)arg;
+#endif
     htt_rx_msdu_buff_replenish(pdev);
 }

diff --git a/CORE/CLD_TXRX/TXRX/ol_tx.c b/CORE/CLD_TXRX/TXRX/ol_tx.c
index 76392d92bc4f..f06af7b7ce1e 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx.c
@@ -769,10 +769,14 @@ ol_tx_pdev_ll_pause_queue_send_all(struct ol_txrx_pdev_t *pdev)
 }
 #endif

-void ol_tx_vdev_ll_pause_queue_send(void *context)
+void ol_tx_vdev_ll_pause_queue_send(compat_timer_arg_t context)
 {
 #ifdef QCA_SUPPORT_TXRX_VDEV_LL_TXQ
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    struct ol_txrx_vdev_t *vdev = from_timer(vdev, context, ll_pause.timer);
+#else
     struct ol_txrx_vdev_t *vdev = (struct ol_txrx_vdev_t *) context;
+#endif

     if (vdev->pdev->tx_throttle.current_throttle_level != THROTTLE_LEVEL_0 &&
         vdev->pdev->tx_throttle.current_throttle_phase == THROTTLE_PHASE_OFF) {
@@ -2110,8 +2114,13 @@ ol_tx_hl_pdev_queue_send_all(struct ol_txrx_pdev_t* pdev)
  * Return: none
  */
 void
-ol_tx_hl_vdev_bundle_timer(void *vdev)
+ol_tx_hl_vdev_bundle_timer(compat_timer_arg_t context)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+	struct ol_txrx_vdev_t *vdev = from_timer(vdev, context, bundle_queue.timer);
+#else
+	struct ol_txrx_vdev_t *vdev = (struct ol_txrx_vdev_t *)context;
+#endif
	adf_nbuf_t msdu_list;

	msdu_list = ol_tx_hl_vdev_queue_send_all(vdev, true);
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx.h b/CORE/CLD_TXRX/TXRX/ol_tx.h
index 986efea00ba7..d40683893d58 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx.h
+++ b/CORE/CLD_TXRX/TXRX/ol_tx.h
@@ -126,7 +126,7 @@ void ol_tx_hl_del_ack_queue_flush_all(struct ol_txrx_vdev_t *vdev)

 #ifdef QCA_SUPPORT_TXRX_HL_BUNDLE
 void
-ol_tx_hl_vdev_bundle_timer(void *vdev);
+ol_tx_hl_vdev_bundle_timer(compat_timer_arg_t vdev);


 void
@@ -137,7 +137,7 @@ ol_tx_hl_queue(struct ol_txrx_vdev_t* vdev, adf_nbuf_t msdu_list);

 #else

-static inline void ol_tx_hl_vdev_bundle_timer(void *vdev)
+static inline void ol_tx_hl_vdev_bundle_timer(compat_timer_arg_t vdev)
 {
	return;
 }
@@ -162,7 +162,7 @@ ol_tx_hl_queue_flush_all(struct ol_txrx_vdev_t* vdev)
 #define OL_TX_HL ol_tx_hl
 #endif

-void ol_tx_vdev_ll_pause_queue_send(void *context);
+void ol_tx_vdev_ll_pause_queue_send(compat_timer_arg_t context);

 adf_nbuf_t
 ol_tx_non_std_ll(
diff --git a/CORE/CLD_TXRX/TXRX/ol_tx_queue.c b/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
index 571295f990bb..6a5c70cd84b5 100644
--- a/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
+++ b/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
@@ -1138,7 +1138,7 @@ ol_txrx_vdev_unpause(ol_txrx_vdev_handle vdev, u_int32_t reason)
 #endif
             if (!vdev->ll_pause.paused_reason) {
                 adf_os_spin_unlock_bh(&vdev->ll_pause.mutex);
-                ol_tx_vdev_ll_pause_queue_send(vdev);
+                ol_tx_vdev_ll_pause_queue_send(&vdev->ll_pause.timer);
             } else {
                 adf_os_spin_unlock_bh(&vdev->ll_pause.mutex);
             }
@@ -1185,9 +1185,13 @@ u_int8_t ol_tx_pdev_is_target_empty(void)
     return 1;
 }

-void ol_tx_pdev_throttle_phase_timer(void *context)
+void ol_tx_pdev_throttle_phase_timer(compat_timer_arg_t context)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    struct ol_txrx_pdev_t *pdev = from_timer(pdev, context, tx_throttle.phase_timer);
+#else
     struct ol_txrx_pdev_t *pdev = (struct ol_txrx_pdev_t *)context;
+#endif
     int ms = 0;
     throttle_level cur_level;
     throttle_phase cur_phase;
@@ -1238,9 +1242,13 @@ void ol_tx_pdev_throttle_phase_timer(void *context)
 }

 #ifdef QCA_SUPPORT_TXRX_VDEV_LL_TXQ
-void ol_tx_pdev_throttle_tx_timer(void *context)
+void ol_tx_pdev_throttle_tx_timer(compat_timer_arg_t context)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    struct ol_txrx_pdev_t *pdev = from_timer(pdev, context, tx_throttle.tx_timer);
+#else
     struct ol_txrx_pdev_t *pdev = (struct ol_txrx_pdev_t *)context;
+#endif
     ol_tx_pdev_ll_pause_queue_send_all(pdev);
 }
 #endif
diff --git a/CORE/EPPING/src/epping_txrx.c b/CORE/EPPING/src/epping_txrx.c
index 2b408ce8ebb4..19131398ab26 100644
--- a/CORE/EPPING/src/epping_txrx.c
+++ b/CORE/EPPING/src/epping_txrx.c
@@ -64,8 +64,11 @@
 static int epping_start_adapter(epping_adapter_t *pAdapter);
 static void epping_stop_adapter(epping_adapter_t *pAdapter);

-static void epping_timer_expire(void *data)
+static void epping_timer_expire(compat_timer_arg_t data)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+   epping_adapter_t *pAdapter = from_timer(pAdapter, data, epping_timer);
+#else
    struct net_device *dev = (struct net_device *) data;
    epping_adapter_t *pAdapter;

@@ -76,6 +79,7 @@ static void epping_timer_expire(void *data)
    }

    pAdapter = netdev_priv(dev);
+#endif
    if (pAdapter == NULL) {
       EPPING_LOG(VOS_TRACE_LEVEL_FATAL,
          "%s: adapter = NULL", __func__);
diff --git a/CORE/HDD/inc/wlan_hdd_p2p.h b/CORE/HDD/inc/wlan_hdd_p2p.h
index 55236875ff24..21551250c85e 100644
--- a/CORE/HDD/inc/wlan_hdd_p2p.h
+++ b/CORE/HDD/inc/wlan_hdd_p2p.h
@@ -172,7 +172,13 @@ int wlan_hdd_mgmt_tx( struct wiphy *wiphy, struct net_device *dev,
 #endif


-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
+struct wireless_dev *wlan_hdd_add_virtual_intf(struct wiphy *wiphy,
+                                               const char *name,
+                                               unsigned char name_assign_type,
+                                               enum nl80211_iftype type,
+                                               struct vif_params *params);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 struct wireless_dev *wlan_hdd_add_virtual_intf(struct wiphy *wiphy,
                                                const char *name,
                                                unsigned char name_assign_type,
diff --git a/CORE/HDD/src/wlan_hdd_assoc.c b/CORE/HDD/src/wlan_hdd_assoc.c
index 3b5991081aa1..545d8d3a6282 100644
--- a/CORE/HDD/src/wlan_hdd_assoc.c
+++ b/CORE/HDD/src/wlan_hdd_assoc.c
@@ -763,7 +763,11 @@ static void hdd_copy_vht_operation(hdd_station_ctx_t *hdd_sta_ctx,

	hdd_vht_ops->chan_width = roam_vht_ops->chanWidth;
	hdd_vht_ops->center_freq_seg1_idx = roam_vht_ops->chanCenterFreqSeg1;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+	hdd_vht_ops->center_freq_seg0_idx = roam_vht_ops->chanCenterFreqSeg2;
+#else
	hdd_vht_ops->center_freq_seg2_idx = roam_vht_ops->chanCenterFreqSeg2;
+#endif
	hdd_vht_ops->basic_mcs_set = roam_vht_ops->basicMCSSet;
 }

diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 4b6333ab2c48..120d58146989 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -983,6 +983,18 @@ static const struct wiphy_wowlan_support wowlan_support_cfg80211_init = {
 };
 #endif

+#define WIPHY_FLAG_DFS_OFFLOAD BIT(22)
+
+int __nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head,
+	      int len, const struct nla_policy *policy)
+{
+	return nla_parse(tb, maxtype, head, len, policy
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+		,NULL
+#endif
+		);
+}
+
 #if defined(FEATURE_WLAN_CH_AVOID) || defined(FEATURE_WLAN_FORCE_SAP_SCC)
 /*
  * FUNCTION: wlan_hdd_send_avoid_freq_event
@@ -1909,7 +1921,7 @@ __wlan_hdd_cfg80211_set_scanning_mac_oui(struct wiphy *wiphy,
         return -ENOTSUPP;
     }

-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_MAX,
                     data, data_len,
                     NULL)) {
         hddLog(LOGE, FL("Invalid ATTR"));
@@ -2027,7 +2039,7 @@ __wlan_hdd_cfg80211_get_concurrency_matrix(struct wiphy *wiphy,
     if (0 != ret)
         return ret;

-    if (nla_parse(tb, MAX_CONCURRENT_MATRIX,
+    if (__nla_parse(tb, MAX_CONCURRENT_MATRIX,
                   data, data_len, wlan_hdd_get_concurrency_matrix_policy)) {
         hddLog(LOGE, FL("Invalid ATTR"));
         return -EINVAL;
@@ -2179,7 +2191,7 @@ __wlan_hdd_cfg80211_set_ext_roam_params(struct wiphy *wiphy,
	if (0 != ret)
		return -EINVAL;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ROAMING_PARAM_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ROAMING_PARAM_MAX,
		data, data_len,
		wlan_hdd_set_roam_param_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
@@ -2217,7 +2229,7 @@ __wlan_hdd_cfg80211_set_ext_roam_params(struct wiphy *wiphy,
			nla_for_each_nested(curr_attr,
				tb[QCA_WLAN_VENDOR_ATTR_ROAMING_PARAM_WHITE_LIST_SSID_LIST],
				rem) {
-				if (nla_parse(tb2,
+				if (__nla_parse(tb2,
					QCA_WLAN_VENDOR_ATTR_ROAM_SUBCMD_MAX,
					nla_data(curr_attr), nla_len(curr_attr),
					wlan_hdd_set_roam_param_policy)) {
@@ -2381,7 +2393,7 @@ __wlan_hdd_cfg80211_set_ext_roam_params(struct wiphy *wiphy,
				break;
			}

-			if (nla_parse(tb2,
+			if (__nla_parse(tb2,
				QCA_WLAN_VENDOR_ATTR_ROAMING_PARAM_MAX,
				nla_data(curr_attr), nla_len(curr_attr),
				wlan_hdd_set_roam_param_policy)) {
@@ -2443,7 +2455,7 @@ __wlan_hdd_cfg80211_set_ext_roam_params(struct wiphy *wiphy,
					hddLog(LOGW, FL("Ignoring excess Blacklist BSSID"));
					break;
				}
-				if (nla_parse(tb2,
+				if (__nla_parse(tb2,
					QCA_WLAN_VENDOR_ATTR_ROAMING_PARAM_MAX,
					nla_data(curr_attr), nla_len(curr_attr),
					wlan_hdd_set_roam_param_policy)) {
@@ -2902,7 +2914,7 @@ static int __wlan_hdd_cfg80211_extscan_get_capabilities(struct wiphy *wiphy,
         hddLog(LOGE, FL("extscan not supported"));
         return -ENOTSUPP;
     }
-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                     data, data_len,
                     wlan_hdd_extscan_config_policy)) {
         hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid ATTR"));
@@ -3045,7 +3057,7 @@ static int __wlan_hdd_cfg80211_extscan_get_cached_results(struct wiphy *wiphy,
		hddLog(LOGE, FL("extscan not supported"));
		return -ENOTSUPP;
	}
-	if (nla_parse(tb, PARAM_MAX, data, data_len,
+	if (__nla_parse(tb, PARAM_MAX, data, data_len,
			wlan_hdd_extscan_config_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
@@ -3180,7 +3192,7 @@ static int __wlan_hdd_cfg80211_extscan_set_bssid_hotlist(struct wiphy *wiphy,
     if (0 != status)
         return -EINVAL;

-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                     data, data_len,
                     wlan_hdd_extscan_config_policy)) {
         hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid ATTR"));
@@ -3242,7 +3254,7 @@ static int __wlan_hdd_cfg80211_extscan_set_bssid_hotlist(struct wiphy *wiphy,
             break;
         }

-        if (nla_parse(tb2, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+        if (__nla_parse(tb2, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                 nla_data(apTh), nla_len(apTh),
                 wlan_hdd_extscan_config_policy)) {
             hddLog(LOGE, FL("nla_parse failed"));
@@ -3377,7 +3389,7 @@ static int __wlan_hdd_cfg80211_extscan_set_significant_change(
     if (0 != retval)
        return -EINVAL;

-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                     data, data_len,
                     wlan_hdd_extscan_config_policy)) {
         hddLog(LOGE, FL("Invalid ATTR"));
@@ -3459,7 +3471,7 @@ static int __wlan_hdd_cfg80211_extscan_set_significant_change(
             break;
         }

-        if (nla_parse(tb2,
+        if (__nla_parse(tb2,
                 QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                 nla_data(apTh), nla_len(apTh),
                 wlan_hdd_extscan_config_policy)) {
@@ -3590,7 +3602,7 @@ static int __wlan_hdd_cfg80211_extscan_get_valid_channels(struct wiphy *wiphy,
     if (0 != retval)
        return -EINVAL;

-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                   data, data_len,
                   wlan_hdd_extscan_config_policy)) {
         hddLog(LOGE, FL("Invalid ATTR"));
@@ -3840,7 +3852,7 @@ static int hdd_extscan_start_fill_bucket_channel_spec(
			break;
		}

-		if (nla_parse(bucket,
+		if (__nla_parse(bucket,
			      QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
			      nla_data(buckets), nla_len(buckets),
			      wlan_hdd_extscan_config_policy)) {
@@ -4063,7 +4075,7 @@ static int hdd_extscan_start_fill_bucket_channel_spec(
							    total_channels))
				break;

-			if (nla_parse(channel,
+			if (__nla_parse(channel,
				QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
				nla_data(channels), nla_len(channels),
				wlan_hdd_extscan_config_policy)) {
@@ -4276,7 +4288,7 @@ static int __wlan_hdd_cfg80211_extscan_start(struct wiphy *wiphy,
		return -ENOTSUPP;
	}

-	if (nla_parse(tb, PARAM_MAX, data, data_len,
+	if (__nla_parse(tb, PARAM_MAX, data, data_len,
		wlan_hdd_extscan_config_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
@@ -4490,7 +4502,7 @@ static int __wlan_hdd_cfg80211_extscan_stop(struct wiphy *wiphy,
		hddLog(LOGE, FL("extscan not supported"));
		return -ENOTSUPP;
	}
-	if (nla_parse(tb, PARAM_MAX, data, data_len,
+	if (__nla_parse(tb, PARAM_MAX, data, data_len,
			wlan_hdd_extscan_config_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
@@ -4609,7 +4621,7 @@ static int __wlan_hdd_cfg80211_extscan_reset_bssid_hotlist(struct wiphy *wiphy,
         hddLog(LOGE, FL("extscan not supported"));
         return -ENOTSUPP;
     }
-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                     data, data_len,
                     wlan_hdd_extscan_config_policy)) {
         hddLog(LOGE, FL("Invalid ATTR"));
@@ -4724,7 +4736,7 @@ static int __wlan_hdd_cfg80211_extscan_reset_significant_change(
         hddLog(LOGE, FL("extscan not supported"));
         return -ENOTSUPP;
     }
-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_EXTSCAN_SUBCMD_CONFIG_PARAM_MAX,
                     data, data_len,
                     wlan_hdd_extscan_config_policy)) {
         hddLog(LOGE, FL("Invalid ATTR"));
@@ -4848,7 +4860,7 @@ static int hdd_extscan_epno_fill_network_list(
			break;
		}

-		if (nla_parse(network, QCA_WLAN_VENDOR_ATTR_PNO_MAX,
+		if (__nla_parse(network, QCA_WLAN_VENDOR_ATTR_PNO_MAX,
			      nla_data(networks), nla_len(networks),
			      wlan_hdd_pno_config_policy)) {
			hddLog(LOGE, FL("nla_parse failed"));
@@ -4943,7 +4955,7 @@ static int __wlan_hdd_cfg80211_set_epno_list(struct wiphy *wiphy,
		return -EINVAL;
	}

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_PNO_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_PNO_MAX,
		      data, data_len,
		      wlan_hdd_pno_config_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
@@ -5157,7 +5169,7 @@ static int hdd_extscan_passpoint_fill_network_list(
			break;
		}

-		if (nla_parse(network,
+		if (__nla_parse(network,
			QCA_WLAN_VENDOR_ATTR_PNO_MAX,
			nla_data(networks), nla_len(networks),
			wlan_hdd_pno_config_policy)) {
@@ -5259,7 +5271,7 @@ static int __wlan_hdd_cfg80211_set_passpoint_list(struct wiphy *wiphy,
		return -EINVAL;
	}

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_PNO_MAX, data, data_len,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_PNO_MAX, data, data_len,
		wlan_hdd_pno_config_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
@@ -5380,7 +5392,7 @@ static int __wlan_hdd_cfg80211_reset_passpoint_list(struct wiphy *wiphy,
		return -EINVAL;
	}

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_PNO_MAX, data, data_len,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_PNO_MAX, data, data_len,
		wlan_hdd_extscan_config_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
@@ -6602,7 +6614,7 @@ static int __wlan_hdd_cfg80211_ll_stats_ext_set_param(struct wiphy *wiphy,
	hddLog(VOS_TRACE_LEVEL_INFO_LOW,
	       FL("Get user layer settings for LL stat. Length is %d bytes"),
	       data_len);
-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_LL_STATS_EXT_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_LL_STATS_EXT_MAX,
		      (struct nlattr *)data, data_len,
		      qca_wlan_vendor_ll_ext_policy)) {
		hddLog(VOS_TRACE_LEVEL_ERROR,
@@ -7592,7 +7604,7 @@ static int __wlan_hdd_cfg80211_ll_stats_set(struct wiphy *wiphy,
     if (0 != status)
         return -EINVAL;

-    if (nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_LL_STATS_SET_MAX,
+    if (__nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_LL_STATS_SET_MAX,
                   (struct nlattr *)data,
                   data_len, qca_wlan_vendor_ll_set_policy))
     {
@@ -7727,7 +7739,7 @@ static int __wlan_hdd_cfg80211_ll_stats_get(struct wiphy *wiphy,
         return -EBUSY;
     }

-    if (nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_LL_STATS_GET_MAX,
+    if (__nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_LL_STATS_GET_MAX,
                   (struct nlattr *)data,
                   data_len, qca_wlan_vendor_ll_get_policy))
     {
@@ -7852,7 +7864,7 @@ static int __wlan_hdd_cfg80211_ll_stats_clear(struct wiphy *wiphy,
         return -EINVAL;
     }

-    if (nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_LL_STATS_CLR_MAX,
+    if (__nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_LL_STATS_CLR_MAX,
                   (struct nlattr *)data,
                   data_len, qca_wlan_vendor_ll_clr_policy))
     {
@@ -8199,7 +8211,7 @@ __wlan_hdd_cfg80211_get_wifi_info(struct wiphy *wiphy,
	if (0 != status)
		return -EINVAL;

-	if (nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_WIFI_INFO_GET_MAX, data,
+	if (__nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_WIFI_INFO_GET_MAX, data,
		      data_len, qca_wlan_vendor_get_wifi_info_policy)) {
		hddLog(LOGE, FL("WIFI_INFO_GET NL CMD parsing failed"));
		return -EINVAL;
@@ -8637,7 +8649,7 @@ __wlan_hdd_cfg80211_thermal_cmd(struct wiphy *wiphy,
	if (wlan_hdd_validate_context(hdd_ctx))
		return -EINVAL;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_THERMAL_CMD_VALUE,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_THERMAL_CMD_VALUE,
			   data, data_len,
			   qca_wlan_vendor_thermal_cmd_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
@@ -8783,7 +8795,7 @@ static int __wlan_hdd_cfg80211_exttdls_get_status(struct wiphy *wiphy,
     if (pHddCtx->cfg_ini->fTDLSExternalControl == FALSE) {
         return -ENOTSUPP;
     }
-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TDLS_GET_STATUS_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TDLS_GET_STATUS_MAX,
                     data, data_len,
                     wlan_hdd_tdls_config_get_status_policy)) {
         hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid attribute"));
@@ -8970,7 +8982,7 @@ static int __wlan_hdd_cfg80211_exttdls_enable(struct wiphy *wiphy,
                FL("TDLS External Control is not enabled"));
         return -ENOTSUPP;
     }
-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TDLS_ENABLE_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TDLS_ENABLE_MAX,
                     data, data_len,
                     wlan_hdd_tdls_config_enable_policy)) {
         hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid ATTR"));
@@ -9086,7 +9098,7 @@ static int __wlan_hdd_cfg80211_exttdls_disable(struct wiphy *wiphy,

         return -ENOTSUPP;
     }
-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TDLS_DISABLE_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TDLS_DISABLE_MAX,
                     data, data_len,
                     wlan_hdd_tdls_config_disable_policy)) {
         hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid ATTR"));
@@ -9272,7 +9284,7 @@ static int __wlan_hdd_cfg80211_disable_dfs_chan_scan(struct wiphy *wiphy,
     if ((ret_val = wlan_hdd_validate_context(pHddCtx)))
         return ret_val;

-    if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SET_NO_DFS_FLAG_MAX,
+    if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SET_NO_DFS_FLAG_MAX,
                     data, data_len,
                     wlan_hdd_set_no_dfs_flag_config_policy)) {
         hddLog(LOGE, FL("invalid attr"));
@@ -9893,7 +9905,7 @@ static int __wlan_hdd_cfg80211_do_acs(struct wiphy *wiphy,
	sap_config = &adapter->sessionCtx.ap.sapConfig;
	vos_mem_zero(&sap_config->acs_cfg, sizeof(struct sap_acs_cfg));

-	status = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ACS_MAX, data, data_len,
+	status = __nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ACS_MAX, data, data_len,
						wlan_hdd_cfg80211_do_acs_policy);
	if (status) {
		hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid ATTR"));
@@ -10586,7 +10598,7 @@ static int __wlan_hdd_cfg80211_wifi_configuration_set(struct wiphy *wiphy,
	if (ret_val)
		return ret_val;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_CONFIG_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_CONFIG_MAX,
		      data, data_len,
		      wlan_hdd_wifi_config_policy)) {
		hddLog(LOGE, FL("invalid attr"));
@@ -11198,7 +11210,7 @@ __wlan_hdd_cfg80211_wifi_configuration_get(struct wiphy *wiphy,
	if (0 != status)
		return -EINVAL;

-	if (nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_CONFIG_MAX, data,
+	if (__nla_parse(tb_vendor, QCA_WLAN_VENDOR_ATTR_CONFIG_MAX, data,
		      data_len, wlan_hdd_wifi_config_policy)) {
		hddLog(LOGE, FL("WIFI_CFG_GET NL CMD parsing failed"));
		return -EINVAL;
@@ -11429,7 +11441,7 @@ static int __wlan_hdd_cfg80211_wifi_logger_start(struct wiphy *wiphy,
	if (0 != status)
		return -EINVAL;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_WIFI_LOGGER_START_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_WIFI_LOGGER_START_MAX,
		      data, data_len,
		      qca_wlan_vendor_wifi_logger_start_policy)) {
		hddLog(LOGE, FL("Invalid attribute"));
@@ -11530,7 +11542,7 @@ static int __wlan_hdd_cfg80211_get_link_properties(struct wiphy *wiphy,
	if (0 != wlan_hdd_validate_context(hdd_ctx))
		return -EINVAL;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len,
		      qca_wlan_vendor_attr_policy)) {
		hddLog(VOS_TRACE_LEVEL_ERROR, FL("Invalid attribute"));
		return -EINVAL;
@@ -11755,7 +11767,7 @@ static int __wlan_hdd_cfg80211_wifi_logger_get_ring_data(struct wiphy *wiphy,
	if (0 != status)
		return -EINVAL;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_WIFI_LOGGER_GET_RING_DATA_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_WIFI_LOGGER_GET_RING_DATA_MAX,
			data, data_len,
			qca_wlan_vendor_wifi_logger_get_ring_data_policy)) {
		hddLog(LOGE, FL("Invalid attribute"));
@@ -12162,7 +12174,7 @@ __wlan_hdd_cfg80211_offloaded_packets(struct wiphy *wiphy,
		return -ENOTSUPP;
	}

-	if (nla_parse(tb, PARAM_MAX, data, data_len, policy)) {
+	if (__nla_parse(tb, PARAM_MAX, data, data_len, policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
	}
@@ -12272,7 +12284,7 @@ __wlan_hdd_cfg80211_monitor_rssi(struct wiphy *wiphy,
		return -ENOTSUPP;
	}

-	if (nla_parse(tb, PARAM_MAX, data, data_len, policy)) {
+	if (__nla_parse(tb, PARAM_MAX, data, data_len, policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
	}
@@ -12529,7 +12541,7 @@ __wlan_hdd_cfg80211_set_ns_offload(struct wiphy *wiphy,
		return -EINVAL;
	}

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ND_OFFLOAD_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ND_OFFLOAD_MAX,
			(struct nlattr *)data,
			data_len, ns_offload_set_policy)) {
		hddLog(LOGE, FL("nla_parse failed"));
@@ -12607,7 +12619,7 @@ __wlan_hdd_cfg80211_setband(struct wiphy *wiphy,
	if (ret)
		return ret;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len, policy)) {
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len, policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
	}
@@ -12959,7 +12971,7 @@ __wlan_hdd_cfg80211_bpf_offload(struct wiphy *wiphy,
		return -ENOTSUPP;
	}

-	if (nla_parse(tb, BPF_MAX, data, data_len,
+	if (__nla_parse(tb, BPF_MAX, data, data_len,
				wlan_hdd_bpf_offload_policy)) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return -EINVAL;
@@ -13408,7 +13420,7 @@ __wlan_hdd_cfg80211_acs_dfs_mode(struct wiphy *wiphy,
	if (0 != ret)
		return -EINVAL;

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ACS_DFS_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_ACS_DFS_MAX,
				data, data_len,
				wlan_hdd_set_acs_dfs_config_policy)) {
		hddLog(LOGE, FL("invalid attr"));
@@ -13581,7 +13593,7 @@ __wlan_hdd_cfg80211_sta_roam_policy(struct wiphy *wiphy,
	ret = wlan_hdd_validate_context(hdd_ctx);
	if (0 != ret)
		return -EINVAL;
-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_STA_CONNECT_ROAM_POLICY_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_STA_CONNECT_ROAM_POLICY_MAX,
				data, data_len,
				wlan_hdd_set_sta_roam_config_policy)) {
		hddLog(LOGE, FL("invalid attr"));
@@ -13834,7 +13846,7 @@ __wlan_hdd_cfg80211_sap_configuration_set(struct wiphy *wiphy,
		return -EINVAL;
	}

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SAP_CONFIG_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_SAP_CONFIG_MAX,
				data, data_len,
				wlan_hdd_sap_config_policy)) {
		hddLog(LOGE, FL("invalid attr"));
@@ -14762,7 +14774,7 @@ __hdd_cfg80211_get_station_cmd(struct wiphy *wiphy,
	if (0 != status)
		goto out;

-	status = nla_parse(tb, STATION_MAX, data, data_len,
+	status = __nla_parse(tb, STATION_MAX, data, data_len,
			   hdd_get_station_policy);
	if (status) {
		hddLog(LOGE, FL("Invalid ATTR"));
@@ -14908,7 +14920,7 @@ static int __wlan_hdd_cfg80211_fast_roaming(struct wiphy *wiphy,
		return -EINVAL;
	}

-	ret = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len,
+	ret = __nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len,
			qca_wlan_vendor_attr);
	if (ret) {
		hddLog(LOGE, FL("Invalid ATTR"));
@@ -15018,7 +15030,7 @@ static int __wlan_hdd_cfg80211_txpower_scale(struct wiphy *wiphy,

	adapter = WLAN_HDD_GET_PRIV_PTR(dev);

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TXPOWER_SCALE_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TXPOWER_SCALE_MAX,
		      data, data_len, txpower_scale_policy)) {
		hddLog(LOGE, "Invalid ATTR");
		return -EINVAL;
@@ -15104,7 +15116,7 @@ static int __wlan_hdd_cfg80211_txpower_scale_decr_db(struct wiphy *wiphy,

	adapter = WLAN_HDD_GET_PRIV_PTR(dev);

-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TXPOWER_SCALE_DECR_DB_MAX,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_TXPOWER_SCALE_DECR_DB_MAX,
		      data, data_len, txpower_scale_decr_db_policy)) {
		hddLog(LOGE, "Invalid ATTR");
		return -EINVAL;
@@ -15228,7 +15240,7 @@ static int __wlan_hdd_cfg80211_get_chain_rssi(struct wiphy *wiphy,
		return retval;

	/* nla validation doesn't do exact lengths, do the validation later */
-	retval = nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len, NULL);
+	retval = __nla_parse(tb, QCA_WLAN_VENDOR_ATTR_MAX, data, data_len, NULL);
	if (retval) {
		hddLog(LOGE, FL("Invalid ATTR"));
		return retval;
@@ -15346,7 +15358,7 @@ __wlan_hdd_cfg80211_peer_flush_pending(struct wiphy *wiphy,
		hddLog(LOGE, FL("Command not allowed in FTM mode"));
		return -EINVAL;
	}
-	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_FLUSH_PENDING_MAX, data,
+	if (__nla_parse(tb, QCA_WLAN_VENDOR_ATTR_FLUSH_PENDING_MAX, data,
		      data_len, qca_wlan_vendor_peer_flush_pending_policy)) {
		hddLog(LOGE, FL("Invalid attribute"));
		return -EINVAL;
@@ -16159,7 +16171,11 @@ int wlan_hdd_cfg80211_init(struct device *dev,
 #ifdef FEATURE_WLAN_SCAN_PNO
     if (pCfg->configPNOScanSupport)
     {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+        wiphy->max_sched_scan_reqs = 1;
+#else
         wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif
         wiphy->max_sched_scan_ssids = SIR_PNO_MAX_SUPP_NETWORKS;
         wiphy->max_match_sets       = SIR_PNO_MAX_SUPP_NETWORKS;
         wiphy->max_sched_scan_ie_len = SIR_MAC_MAX_IE_LENGTH;
@@ -16485,7 +16501,11 @@ void wlan_hdd_cfg80211_update_wiphy_caps(struct wiphy *wiphy)
     * control comes here. Here just we need to clear it if firmware doesn't
     * have PNO support. */
    if (!pCfg->PnoOffload) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+       wiphy->max_sched_scan_reqs = 0;
+#else
        wiphy->flags &= ~WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif
        wiphy->max_sched_scan_ssids = 0;
        wiphy->max_match_sets = 0;
        wiphy->max_sched_scan_ie_len = 0;
@@ -19945,13 +19965,23 @@ done:
  * FUNCTION: wlan_hdd_cfg80211_change_iface
  * wrapper function to protect the actual implementation from SSR.
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+static int wlan_hdd_cfg80211_change_iface(struct wiphy *wiphy,
+                                          struct net_device *ndev,
+                                          enum nl80211_iftype type,
+                                          struct vif_params *params)
+#else
 static int wlan_hdd_cfg80211_change_iface(struct wiphy *wiphy,
                                           struct net_device *ndev,
                                           enum nl80211_iftype type,
                                           u32 *flags,
                                           struct vif_params *params)
+#endif
 {
     int ret;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+    u32 *flags = NULL;
+#endif

     vos_ssr_protect(__func__);
     ret = __wlan_hdd_cfg80211_change_iface(wiphy, ndev, type, flags, params);
@@ -28252,7 +28282,11 @@ void hdd_cfg80211_sched_scan_done_callback(void *callbackContext,
          */
         hdd_prevent_suspend_timeout(1000, WIFI_POWER_EVENT_WAKELOCK_SCAN);
     }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+    cfg80211_sched_scan_results(pHddCtx->wiphy, 0);
+#else
     cfg80211_sched_scan_results(pHddCtx->wiphy);
+#endif
     VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
             "%s: cfg80211 scan result database updated", __func__);
 }
@@ -28748,8 +28782,13 @@ static int __wlan_hdd_cfg80211_sched_scan_stop(struct wiphy *wiphy,
  * FUNCTION: wlan_hdd_cfg80211_sched_scan_stop
  * NL interface to disable PNO
  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+static int wlan_hdd_cfg80211_sched_scan_stop(struct wiphy *wiphy,
+          struct net_device *dev, u64 reqid)
+#else
 static int wlan_hdd_cfg80211_sched_scan_stop(struct wiphy *wiphy,
           struct net_device *dev)
+#endif
 {
     int ret;

@@ -30154,7 +30193,7 @@ static int __wlan_hdd_cfg80211_testmode(struct wiphy *wiphy,

     ENTER();

-    err = nla_parse(tb, WLAN_HDD_TM_ATTR_MAX, data, len, wlan_hdd_tm_policy);
+    err = __nla_parse(tb, WLAN_HDD_TM_ATTR_MAX, data, len, wlan_hdd_tm_policy);
     if (err) {
         hddLog(LOGE, FL("Testmode INV ATTR"));
         return err;
@@ -30816,7 +30855,11 @@ int __wlan_hdd_cfg80211_resume_wlan(struct wiphy *wiphy, bool thermal)
                  */
                 hdd_prevent_suspend_timeout(1000,
                                          WIFI_POWER_EVENT_WAKELOCK_RESUME_WLAN);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+                cfg80211_sched_scan_results(pHddCtx->wiphy, 0);
+#else
                 cfg80211_sched_scan_results(pHddCtx->wiphy);
+#endif
             }

             hddLog(LOG1, FL("cfg80211 scan result database updated"));
diff --git a/CORE/HDD/src/wlan_hdd_early_suspend.c b/CORE/HDD/src/wlan_hdd_early_suspend.c
index c9dce99ad53b..b28c7d0ad963 100644
--- a/CORE/HDD/src/wlan_hdd_early_suspend.c
+++ b/CORE/HDD/src/wlan_hdd_early_suspend.c
@@ -1974,9 +1974,15 @@ VOS_STATUS hdd_wlan_reset_initialization(void)
    return VOS_STATUS_SUCCESS;
 }

+static void hdd_ssr_timer_cb(compat_timer_arg_t data);
+
 static void hdd_ssr_timer_init(void)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    timer_setup(&ssr_timer, hdd_ssr_timer_cb, 0);
+#else
     init_timer(&ssr_timer);
+#endif
 }

 static void hdd_ssr_timer_del(void)
@@ -1985,7 +1991,7 @@ static void hdd_ssr_timer_del(void)
     ssr_timer_started = false;
 }

-static void hdd_ssr_timer_cb(unsigned long data)
+static void hdd_ssr_timer_cb(compat_timer_arg_t data)
 {
     hddLog(VOS_TRACE_LEVEL_FATAL, "%s: HDD SSR timer expired!", __func__);
     VOS_BUG(0);
@@ -1999,7 +2005,9 @@ static void hdd_ssr_timer_start(int msec)
                "it's running!", __func__);
     }
     ssr_timer.expires = jiffies + msecs_to_jiffies(msec);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
     ssr_timer.function = hdd_ssr_timer_cb;
+#endif
     add_timer(&ssr_timer);
     ssr_timer_started = true;
 }
diff --git a/CORE/HDD/src/wlan_hdd_hostapd.c b/CORE/HDD/src/wlan_hdd_hostapd.c
index eb824a4a6a63..35b9bf6b3755 100644
--- a/CORE/HDD/src/wlan_hdd_hostapd.c
+++ b/CORE/HDD/src/wlan_hdd_hostapd.c
@@ -7949,7 +7949,11 @@ hdd_adapter_t* hdd_wlan_create_ap_dev(hdd_context_t *pHddCtx,
         vos_mem_copy(pHostapdAdapter->macAddressCurrent.bytes, (void *)macAddr, sizeof(tSirMacAddr));

         pHostapdAdapter->offloads_configured = FALSE;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+        pWlanHostapdDev->needs_free_netdev = true;
+#else
         pWlanHostapdDev->destructor = free_netdev;
+#endif
         pWlanHostapdDev->ieee80211_ptr = &pHostapdAdapter->wdev ;
         pHostapdAdapter->wdev.wiphy = pHddCtx->wiphy;
         pHostapdAdapter->wdev.netdev =  pWlanHostapdDev;
diff --git a/CORE/HDD/src/wlan_hdd_main.c b/CORE/HDD/src/wlan_hdd_main.c
index fe9f3f234ef0..7af16df1bd67 100644
--- a/CORE/HDD/src/wlan_hdd_main.c
+++ b/CORE/HDD/src/wlan_hdd_main.c
@@ -11050,7 +11050,11 @@ static hdd_adapter_t* hdd_alloc_station_adapter(hdd_context_t *pHddCtx,
       pWlanDev->features |= NETIF_F_RXCSUM;
       hdd_set_station_ops( pAdapter->dev );

+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+      pWlanDev->needs_free_netdev = true;
+#else
       pWlanDev->destructor = free_netdev;
+#endif
       pWlanDev->ieee80211_ptr = &pAdapter->wdev ;
       pWlanDev->tx_queue_len = HDD_NETDEV_TX_QUEUE_LEN;
       pAdapter->wdev.wiphy = pHddCtx->wiphy;
@@ -11123,7 +11127,11 @@ static hdd_adapter_t *hdd_alloc_monitor_adapter(hdd_context_t *pHddCtx,
	   pwlan_dev->features |= NETIF_F_RXCSUM;
	   hdd_set_monitor_ops(pAdapter->dev);

+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+	   pwlan_dev->needs_free_netdev = true;
+#else
	   pwlan_dev->destructor = free_netdev;
+#endif
	   pwlan_dev->ieee80211_ptr = &pAdapter->wdev;
	   pwlan_dev->tx_queue_len = HDD_NETDEV_TX_QUEUE_LEN;
	   pAdapter->wdev.wiphy = pHddCtx->wiphy;
@@ -17982,9 +17990,15 @@ static bool unload_timer_started;
  *
  * Return: None
  */
+static void hdd_unload_timer_cb(compat_timer_arg_t data);
+
 static void hdd_unload_timer_init(void)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    timer_setup(&unload_timer, hdd_unload_timer_cb, 0);
+#else
	init_timer(&unload_timer);
+#endif
 }

 /**
@@ -18007,7 +18021,7 @@ static void hdd_unload_timer_del(void)
  *
  * Return: None
  */
-static void hdd_unload_timer_cb(unsigned long data)
+static void hdd_unload_timer_cb(compat_timer_arg_t data)
 {
	v_CONTEXT_t vos_context = NULL;
	hdd_context_t *hdd_ctx = NULL;
@@ -18047,7 +18061,9 @@ static void hdd_unload_timer_start(int msec)
			"%s: Starting unload timer when it's running!",
			__func__);
	unload_timer.expires = jiffies + msecs_to_jiffies(msec);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
	unload_timer.function = hdd_unload_timer_cb;
+#endif
	add_timer(&unload_timer);
	unload_timer_started = true;
 }
diff --git a/CORE/HDD/src/wlan_hdd_nan_datapath.c b/CORE/HDD/src/wlan_hdd_nan_datapath.c
index feb1a2b64504..efcd25a79615 100644
--- a/CORE/HDD/src/wlan_hdd_nan_datapath.c
+++ b/CORE/HDD/src/wlan_hdd_nan_datapath.c
@@ -1928,7 +1928,11 @@ static int __wlan_hdd_cfg80211_process_ndp_cmd(struct wiphy *wiphy,
	}
	if (nla_parse(tb, QCA_WLAN_VENDOR_ATTR_NDP_PARAMS_MAX,
			data, data_len,
-			qca_wlan_vendor_ndp_policy)) {
+			qca_wlan_vendor_ndp_policy
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+			, NULL
+#endif
+			)) {
		hddLog(LOGE, FL("Invalid NDP vendor command attributes"));
		return -EINVAL;
	}
diff --git a/CORE/HDD/src/wlan_hdd_p2p.c b/CORE/HDD/src/wlan_hdd_p2p.c
index 596141cfec52..eb0548bc721c 100644
--- a/CORE/HDD/src/wlan_hdd_p2p.c
+++ b/CORE/HDD/src/wlan_hdd_p2p.c
@@ -3006,7 +3006,34 @@ struct wireless_dev* __wlan_hdd_add_virtual_intf(
 #endif
 }

-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0))
+/**
+ * wlan_hdd_add_virtual_intf() - Add virtual interface wrapper
+ * @wiphy: wiphy pointer
+ * @name: User-visible name of the interface
+ * @name_assign_type: the name of assign type of the netdev
+ * @nl80211_iftype: (virtual) interface types
+ * @flags: monitor mode configuration flags (not used)
+ * @vif_params: virtual interface parameters (not used)
+ *
+ * Return: the pointer of wireless dev, otherwise NULL.
+ */
+struct wireless_dev *wlan_hdd_add_virtual_intf(struct wiphy *wiphy,
+                                               const char *name,
+                                               unsigned char name_assign_type,
+                                               enum nl80211_iftype type,
+                                               struct vif_params *params)
+{
+    struct wireless_dev *wdev;
+    u32 *flags = NULL;
+
+    vos_ssr_protect(__func__);
+    wdev = __wlan_hdd_add_virtual_intf(wiphy, name, name_assign_type,
+                                       type, flags, params);
+    vos_ssr_unprotect(__func__);
+    return wdev;
+}
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
 /**
  * wlan_hdd_add_virtual_intf() - Add virtual interface wrapper
  * @wiphy: wiphy pointer
diff --git a/CORE/HDD/src/wlan_hdd_tx_rx.c b/CORE/HDD/src/wlan_hdd_tx_rx.c
index f84a6d8efda2..fe3462eb9127 100644
--- a/CORE/HDD/src/wlan_hdd_tx_rx.c
+++ b/CORE/HDD/src/wlan_hdd_tx_rx.c
@@ -1445,6 +1445,7 @@ VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
    while (NULL != skb) {
       skb_next = skb->next;

+#if 0
       if (((pHddStaCtx->conn_info.proxyARPService) &&
          cfg80211_is_gratuitous_arp_unsolicited_na(skb)) ||
          vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
@@ -1457,6 +1458,7 @@ VOS_STATUS hdd_rx_packet_cbk(v_VOID_t *vosContext,
             skb = skb_next;
             continue;
       }
+#endif

       DPTRACE(adf_dp_trace(skb,
               ADF_DP_TRACE_RX_HDD_PACKET_PTR_RECORD,
diff --git a/CORE/SERVICES/COMMON/adf/adf_os_types.h b/CORE/SERVICES/COMMON/adf/adf_os_types.h
index a1b5ce591c01..5ca432050aef 100644
--- a/CORE/SERVICES/COMMON/adf/adf_os_types.h
+++ b/CORE/SERVICES/COMMON/adf/adf_os_types.h
@@ -297,7 +297,13 @@ typedef a_bool_t (*adf_os_irqlocked_func_t)(void *);
 /**
  * @brief Prototype of timer function
  */
-typedef void (*adf_os_timer_func_t)(void *);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)) && !defined(timer_setup)
+typedef unsigned long compat_timer_arg_t;
+#else
+typedef struct timer_list *compat_timer_arg_t;
+#endif
+
+typedef void (*adf_os_timer_func_t)(compat_timer_arg_t);

 /**
  * @brief Prototype of IRQ function.
diff --git a/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h b/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h
index d0e9e6322ed4..b2e1f64c6a27 100644
--- a/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h
+++ b/CORE/SERVICES/COMMON/adf/linux/adf_os_dma_pvt.h
@@ -74,8 +74,13 @@ __adf_os_dmamem_alloc(adf_os_device_t     osdev,
        vaddr = dma_alloc_coherent(osdev->dev, size, &lmap->seg[0].daddr,
                                   GFP_ATOMIC);
    else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+       vaddr = dma_alloc_attrs(osdev->dev, size, &lmap->seg[0].daddr,
+                                     GFP_ATOMIC, DMA_ATTR_NON_CONSISTENT);
+#else
        vaddr = dma_alloc_noncoherent(osdev->dev, size, &lmap->seg[0].daddr,
                                      GFP_ATOMIC);
+#endif

    adf_os_assert(vaddr);

@@ -100,7 +105,11 @@ __adf_os_dmamem_free(adf_os_device_t    osdev, __adf_os_size_t size,
     if(coherent)
         dma_free_coherent(osdev->dev, size, vaddr, dmap->seg[0].daddr);
     else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+        dma_free_attrs(osdev->dev, size, vaddr, dmap->seg[0].daddr, DMA_ATTR_NON_CONSISTENT);
+#else
         dma_free_noncoherent(osdev->dev, size, vaddr, dmap->seg[0].daddr);
+#endif

     kfree(dmap);
 }
diff --git a/CORE/SERVICES/COMMON/adf/linux/adf_os_timer_pvt.h b/CORE/SERVICES/COMMON/adf/linux/adf_os_timer_pvt.h
index d12b74a31163..ac63e0b85804 100644
--- a/CORE/SERVICES/COMMON/adf/linux/adf_os_timer_pvt.h
+++ b/CORE/SERVICES/COMMON/adf/linux/adf_os_timer_pvt.h
@@ -70,12 +70,19 @@ __adf_os_timer_init(adf_os_handle_t      hdl,
                     void                *arg,
                     uint8_t type)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    if (ADF_DEFERRABLE_TIMER == type)
+        timer_setup(timer, func, TIMER_DEFERRABLE);
+    else
+        timer_setup(timer, func, 0);
+#else
     if (ADF_DEFERRABLE_TIMER == type)
         init_timer_deferrable(timer);
     else
         init_timer(timer);
     timer->function = (adf_dummy_timer_func_t)func;
     timer->data = (unsigned long)arg;
+#endif

     return A_STATUS_OK;
 }
diff --git a/CORE/SERVICES/COMMON/osdep_adf.h b/CORE/SERVICES/COMMON/osdep_adf.h
index 4e2ff99eb516..63eff9e9ca45 100644
--- a/CORE/SERVICES/COMMON/osdep_adf.h
+++ b/CORE/SERVICES/COMMON/osdep_adf.h
@@ -442,7 +442,7 @@ typedef struct _NIC_DEV * osdev_t;


 typedef struct timer_list        os_timer_t;
-typedef void (*timer_func)(void *);
+typedef void (*timer_func)(compat_timer_arg_t);

 typedef struct _os_mesg_t {
     STAILQ_ENTRY(_os_mesg_t)  mesg_next;
@@ -635,7 +635,7 @@ typedef dma_addr_t * dma_context_t;
 #define OS_DECLARE_TIMER(_fn)                  void _fn(void *)

 #define OS_TIMER_FUNC(_fn)                     \
-    void _fn(void *timer_arg)
+    void _fn(compat_timer_arg_t timer_arg)

 #define OS_GET_TIMER_ARG(_arg, _type)          \
     (_arg) = (_type)(timer_arg)
@@ -677,9 +677,13 @@ typedef enum _mesgq_event_delivery_type {
  */

 static INLINE void
-os_mesgq_handler(void *timer_arg)
+os_mesgq_handler(compat_timer_arg_t timer_arg)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    os_mesg_queue_t    *queue = from_timer(queue, timer_arg, _timer);
+#else
     os_mesg_queue_t    *queue = (os_mesg_queue_t*)timer_arg;
+#endif
     os_mesg_t          *mesg = NULL;
     void               *msg;

diff --git a/CORE/SERVICES/HIF/PCIe/copy_engine.c b/CORE/SERVICES/HIF/PCIe/copy_engine.c
index ebece13f3e05..ccf1b32a2a06 100644
--- a/CORE/SERVICES/HIF/PCIe/copy_engine.c
+++ b/CORE/SERVICES/HIF/PCIe/copy_engine.c
@@ -1305,9 +1305,13 @@ more_watermarks:
 }

 static void
-CE_poll_timeout(void *arg)
+CE_poll_timeout(compat_timer_arg_t arg)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    struct CE_state *CE_state = from_timer(CE_state, arg, poll_timer);
+#else
     struct CE_state *CE_state = (struct CE_state *) arg;
+#endif
     if (CE_state->timer_inited) {
         CE_per_engine_service(CE_state->sc, CE_state->id);
         adf_os_timer_mod(&CE_state->poll_timer, CE_POLL_TIMEOUT);
diff --git a/CORE/SERVICES/HIF/PCIe/hif_pci.c b/CORE/SERVICES/HIF/PCIe/hif_pci.c
index 280976459e56..b5e5ef74ef3c 100644
--- a/CORE/SERVICES/HIF/PCIe/hif_pci.c
+++ b/CORE/SERVICES/HIF/PCIe/hif_pci.c
@@ -2360,9 +2360,13 @@ HIF_wake_target_cpu(struct hif_pci_softc *sc)
 #define HIF_MIN_SLEEP_INACTIVITY_TIME_MS     50
 #define HIF_SLEEP_INACTIVITY_TIMER_PERIOD_MS 60
 static void
-HIF_sleep_entry(void *arg)
+HIF_sleep_entry(compat_timer_arg_t arg)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+	struct HIF_CE_state *hif_state = from_timer(hif_state, arg, sleep_timer);
+#else
	struct HIF_CE_state *hif_state = (struct HIF_CE_state *)arg;
+#endif
	A_target_id_t pci_addr = TARGID_TO_PCI_ADDR(hif_state->targid);
	struct hif_pci_softc *sc = hif_state->sc;
	u_int32_t idle_ms;
diff --git a/CORE/SERVICES/HTC/htc_internal.h b/CORE/SERVICES/HTC/htc_internal.h
index f6bd7cdd10be..f8c10ed74f83 100644
--- a/CORE/SERVICES/HTC/htc_internal.h
+++ b/CORE/SERVICES/HTC/htc_internal.h
@@ -282,7 +282,7 @@ void        HTCProcessCreditRpt(HTC_TARGET        *target,
                                 int                NumEntries,
                                 HTC_ENDPOINT_ID    FromEndpoint);
 void        HTCFwEventHandler(void *context, A_STATUS status);
-void        HTCSendCompleteCheckCleanup(void *context);
+void        HTCSendCompleteCheckCleanup(compat_timer_arg_t context);
 void        HTCTxResumeAllHandler(void *context);

 void htc_credit_record(htc_credit_exchange_type type, A_UINT32 tx_credit,
diff --git a/CORE/SERVICES/HTC/htc_send.c b/CORE/SERVICES/HTC/htc_send.c
index d231ce509bc1..e36ec7cf202e 100644
--- a/CORE/SERVICES/HTC/htc_send.c
+++ b/CORE/SERVICES/HTC/htc_send.c
@@ -160,9 +160,13 @@ static void SendPacketCompletion(HTC_TARGET *target, HTC_PACKET *pPacket)
 }

 void
-HTCSendCompleteCheckCleanup(void *context)
+HTCSendCompleteCheckCleanup(compat_timer_arg_t context)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+    HTC_ENDPOINT *pEndpoint = from_timer(pEndpoint, context, ul_poll_timer);
+#else
     HTC_ENDPOINT *pEndpoint = (HTC_ENDPOINT *) context;
+#endif
     HTCSendCompleteCheck(pEndpoint, 1);
 }

diff --git a/CORE/VOSS/src/vos_nvitem.c b/CORE/VOSS/src/vos_nvitem.c
index e4e2a73c6697..86d73c7c8bf6 100644
--- a/CORE/VOSS/src/vos_nvitem.c
+++ b/CORE/VOSS/src/vos_nvitem.c
@@ -1676,10 +1676,12 @@ VOS_STATUS vos_nv_getRegDomainFromCountryCode( v_REGDOMAIN_t *pRegDomain,
             vos_set_cc_source(CNSS_SOURCE_11D);

         INIT_COMPLETION(pHddCtx->reg_init);
+#if 0
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0)) || defined(WITH_BACKPORTS)
         regulatory_hint_user(country_code, NL80211_USER_REG_HINT_USER);
 #else
         regulatory_hint_user(country_code);
+#endif
 #endif
         wait_result = wait_for_completion_interruptible_timeout(
                                &pHddCtx->reg_init,
diff --git a/CORE/VOSS/src/vos_timer.c b/CORE/VOSS/src/vos_timer.c
index f17539abcb55..052360c213f7 100644
--- a/CORE/VOSS/src/vos_timer.c
+++ b/CORE/VOSS/src/vos_timer.c
@@ -112,9 +112,13 @@ static void tryAllowingSleep( VOS_TIMER_TYPE type )

   --------------------------------------------------------------------------*/

-static void vos_linux_timer_callback (unsigned long data)
+static void vos_linux_timer_callback (compat_timer_arg_t data)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+   vos_timer_t *timer = from_timer(timer, data, platformInfo.Timer);
+#else
    vos_timer_t *timer = ( vos_timer_t *)data;
+#endif
    vos_msg_t msg;
    VOS_STATUS vStatus;
    unsigned long flags;
@@ -474,12 +478,19 @@ VOS_STATUS vos_timer_init( vos_timer_t *timer, VOS_TIMER_TYPE timerType,
    // set the various members of the timer structure
    // with arguments passed or with default values
    spin_lock_init(&timer->platformInfo.spinlock);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0))
+   if (VOS_TIMER_TYPE_SW == timerType)
+      timer_setup(&(timer->platformInfo.Timer), vos_linux_timer_callback, TIMER_DEFERRABLE);
+   else
+      timer_setup(&(timer->platformInfo.Timer), vos_linux_timer_callback, 0);
+#else
    if (VOS_TIMER_TYPE_SW == timerType)
       init_timer_deferrable(&(timer->platformInfo.Timer));
    else
       init_timer(&(timer->platformInfo.Timer));
    timer->platformInfo.Timer.function = vos_linux_timer_callback;
    timer->platformInfo.Timer.data = (unsigned long)timer;
+#endif
    timer->callback = callback;
    timer->userData = userData;
    timer->type = timerType;
diff --git a/Kbuild b/Kbuild
index 70f88c418d3e..bb837372e9bb 100644
--- a/Kbuild
+++ b/Kbuild
@@ -191,7 +191,7 @@ endif
 # Feature flags which are not (currently) configurable via Kconfig

 #Whether to build debug version
-BUILD_DEBUG_VERSION := 1
+BUILD_DEBUG_VERSION := 0

 #Enable this flag to build driver in diag version
 BUILD_DIAG_VERSION := 1
@@ -1017,7 +1017,6 @@ CDEFINES :=	-DANI_LITTLE_BYTE_ENDIAN \
		-DWLAN_PERF \
		-DPTT_SOCK_SVC_ENABLE \
		-Wall\
-		-Werror\
		-D__linux__ \
		-DHAL_SELF_STA_PER_BSS=1 \
		-DWLAN_FEATURE_VOWIFI_11R \
diff --git a/Makefile b/Makefile
index f78d774f595d..0a356985d78c 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,9 @@
+KBUILD_EXTRA :=
+KBUILD_EXTRA += CONFIG_NON_QC_PLATFORM=y
+KBUILD_EXTRA += CONFIG_ROME_IF=pci
+KBUILD_EXTRA += CONFIG_LINUX_QCMBR=y
+KBUILD_EXTRA += CONFIG_WLAN_FEATURE_11W=y
+
 KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build

 KBUILD_OPTIONS := WLAN_ROOT=$(PWD)
--
2.18.0
